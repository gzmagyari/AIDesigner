<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Stitch ‚Äì AI Design Canvas (Vue2 + OpenAI)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

      [v-cloak] { display: none; }

      :root {
        color-scheme: dark; /* CRITICAL: Tells browser to render form controls in dark mode */
        --bg: #000000;
        --panel: #0c0c0c;
        --panel-header: #111111;
        --border: #2b2b2b;
        --text: #eeeeee;
        --text-dim: #a1a1aa;
        --accent: #3b82f6;
        --accent-hover: #2563eb;
        --input-bg: #18181b;
        --bubble-user: #18181b;
        --bubble-assistant: transparent;
        --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }

      /* ... (rest of styles) ... */

      .model-selector select {
        appearance: none;
        -webkit-appearance: none;
        background-color: #18181b; /* Explicit dark background */
        border: 1px solid var(--border);
        color: #eeeeee;
        font-size: 11px;
        font-weight: 500;
        font-family: var(--font-sans);
        cursor: pointer;
        outline: none;
        padding: 6px 24px 6px 8px;
        border-radius: 6px;
        transition: all 0.2s;
      }

      * { box-sizing: border-box; }
      
      html, body { height: 100%; }
      
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: var(--font-sans);
        font-size: 13px;
        line-height: 1.5;
        -webkit-font-smoothing: antialiased;
      }

      a { color: var(--accent); text-decoration: none; }
      
      .app {
        display: grid;
        grid-template-columns: 450px 1fr;
        height: 100vh;
      }

      /* --- Sidebar (Left) --- */
      .left {
        display: grid;
        grid-template-rows: auto 1fr auto;
        border-right: 1px solid var(--border);
        background: var(--panel);
        overflow: hidden;
        position: relative;
      }

      /* Header */
      .header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        background: var(--panel-header);
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: 50px;
      }

      .header .title {
        font-weight: 600;
        font-size: 14px;
        color: var(--text);
      }

      .header .actions {
        display: flex;
        gap: 4px;
      }

      .btn-icon {
        background: transparent;
        border: none;
        color: var(--text-dim);
        padding: 6px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .btn-icon:hover {
        color: var(--text);
        background: rgba(255,255,255,0.1);
      }

      /* Settings Modal */
      .settings-modal {
        position: absolute;
        top: 50px;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 20;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 20px;
      }

      .settings-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0,0,0,0.5);
        backdrop-filter: blur(2px);
        z-index: 1;
      }

      .settings-content {
        position: relative;
        z-index: 2;
        background: #18181b;
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 20px;
        width: 300px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .settings-content h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        font-weight: 600;
      }

      .settings-content label {
        display: block;
      }

      .settings-content small {
        display: block;
        color: var(--text-dim);
        margin-bottom: 6px;
        font-size: 11px;
        text-transform: uppercase;
        font-weight: 500;
      }

      .settings-content input,
      .settings-content select {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: #000;
        color: var(--text);
        font-family: var(--font-sans);
        font-size: 12px;
        outline: none;
      }

      .settings-content input:focus,
      .settings-content select:focus {
        border-color: var(--accent);
      }

      /* Buttons */
      .btn {
        background: var(--input-bg);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn:hover {
        background: #27272a;
        border-color: #3f3f46;
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
      }

      .btn.primary:hover {
        background: var(--accent-hover);
      }
      
      .btn.full { width: 100%; }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Chat Area */
      .chat {
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .bubble {
        padding: 0;
        border: none;
        background: transparent;
        color: var(--text);
        font-size: 13px;
      }

      .bubble.user {
        background: var(--bubble-user);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid var(--border);
      }

      .bubble.assistant {
        padding-left: 4px;
      }

      .role {
        font-size: 11px;
        font-weight: 600;
        color: var(--text-dim);
        margin-bottom: 6px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      /* Markdown Styles */
      .bubble p { margin: 0 0 8px 0; }
      .bubble p:last-child { margin-bottom: 0; }
      
      .bubble pre {
        background: #18181b;
        border: 1px solid var(--border);
        padding: 12px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 8px 0;
        font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        font-size: 12px;
      }
      
      .bubble code {
        font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        background: rgba(255,255,255,0.1);
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 12px;
      }
      
      .bubble pre code {
        background: transparent;
        padding: 0;
        color: #e5e7eb;
      }

      .bubble ul, .bubble ol {
        margin: 8px 0;
        padding-left: 20px;
      }

      /* Input Area */
      .input {
        padding: 16px;
        border-top: 1px solid var(--border);
        background: var(--panel);
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .input textarea {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--input-bg);
        color: var(--text);
        font-family: var(--font-sans);
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s;
        resize: none;
        min-height: 44px;
        max-height: 200px;
        overflow-y: hidden;
      }

      .input textarea:focus {
        border-color: var(--accent);
      }

      .input-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .model-selector {
        position: relative;
        display: flex;
        align-items: center;
      }
      
      .model-selector select {
        appearance: none;
        -webkit-appearance: none;
        background-color: #18181b;
        border: 1px solid var(--border);
        color: #eeeeee;
        font-size: 11px;
        font-weight: 500;
        font-family: var(--font-sans);
        cursor: pointer;
        outline: none;
        padding: 6px 24px 6px 8px;
        border-radius: 6px;
        transition: all 0.2s;
      }
      
      .model-selector select:hover {
        color: var(--text);
        background-color: rgba(255,255,255,0.05);
      }

      .model-selector select option {
        background-color: #18181b;
        color: var(--text);
        padding: 8px;
      }

      /* Custom arrow */
      .model-selector::after {
        content: '';
        position: absolute;
        right: 8px;
        top: 50%;
        margin-top: -1px;
        width: 0; 
        height: 0; 
        border-left: 3px solid transparent;
        border-right: 3px solid transparent;
        border-top: 4px solid var(--text-dim);
        pointer-events: none;
      }

      .model-selector:hover::after {
        border-top-color: var(--text);
      }

      /* Attachments */
      .attachments {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
      }
      
      .thumb {
        position: relative;
        width: 48px;
        height: 48px;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
        background: #000;
      }
      
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .thumb .remove {
        position: absolute;
        top: 2px;
        right: 2px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(0,0,0,0.7);
        color: white;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        cursor: pointer;
      }
      .input .attachments { grid-column: 1 / -1; }

      /* --- Canvas (Right) --- */
      .right {
        position: relative;
        background: #000; /* Deep black for canvas bg */
        background-image: 
          radial-gradient(circle at 50% 50%, #111 1px, transparent 1px);
        background-size: 24px 24px; /* Dot pattern */
      }

      .canvas {
        position: absolute;
        inset: 0;
        overflow: auto;
        padding: 40px;
      }

      .box {
        position: absolute;
        background: #000;
        border: 1px solid var(--border);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .box-toolbar {
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        background: var(--panel-header);
        border-bottom: 1px solid var(--border);
        font-size: 11px;
        color: var(--text-dim);
      }

      .box-toolbar .title {
        font-weight: 500;
      }

      .box-toolbar button {
        background: transparent;
        border: none;
        color: var(--text-dim);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
      }

      .box-toolbar button:hover {
        color: var(--text);
        background: rgba(255,255,255,0.1);
      }

      .box-content {
        position: relative;
        flex: 1;
        background: #fff; /* Content inside box is usually light unless specified otherwise */
        overflow: auto;
      }
      
      .box.preview {
        border: 1px dashed var(--accent);
        opacity: 0.8;
      }
      
      .box.fullscreen {
        position: absolute !important;
        inset: 24px !important;
        left: 24px !important;
        top: 24px !important;
        right: 24px !important;
        bottom: 24px !important;
        width: auto !important;
        height: auto !important;
        z-index: 9999 !important;
      }

      .empty {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--text-dim);
      }
      
      .empty .hint {
        font-size: 13px;
        margin-top: 8px;
      }

      .box-code {
        position: absolute;
        inset: 40px 0 0 0;
        background: #1e1e1e;
        display: flex;
        flex-direction: column;
        z-index: 10;
      }
      .box-code textarea {
        flex: 1;
        background: #1e1e1e;
        color: #d4d4d4;
        border: none;
        padding: 10px;
        font-family: monospace;
        font-size: 12px;
        resize: none;
        outline: none;
      }
      .code-actions {
        padding: 8px;
        border-top: 1px solid var(--border);
        background: var(--panel);
        text-align: right;
      }
      .box-toolbar .actions.left {
        margin-right: auto;
        display: flex;
        gap: 4px;
      }
      .box-toolbar .sep {
        width: 1px;
        background: var(--border);
        margin: 0 4px;
      }
      .box-toolbar button.active {
        color: var(--accent);
        background: rgba(59, 130, 246, 0.1);
      }
      .btn.small {
        padding: 4px 12px;
        font-size: 11px;
        height: 24px;
      }

      .resizer {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        cursor: col-resize;
        z-index: 100;
        background: transparent;
        transition: background 0.2s;
      }
      .resizer:hover, .resizer.active {
        background: rgba(59, 130, 246, 0.5); /* accent with opacity */
      }
    </style>

    <!-- CDN libs -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <div id="app" class="app" :style="{ gridTemplateColumns: sidebarWidth + 'px 1fr' }" v-cloak>
      <!-- LEFT: Controls & Chat -->
      <section class="left">
        <div class="resizer" @mousedown="startResize" :class="{ active: isResizing }"></div>
        <!-- Header -->
        <div class="header">
          <div class="title">AI Designer</div>
          <div class="actions">
            <button class="btn-icon" @click="clearChat()" title="Clear chat">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
            </button>
            <button class="btn-icon" @click="newCanvas()" title="New canvas">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
            </button>
            <button class="btn-icon" @click="listDesignsToChat()" title="List designs">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
            </button>
            <button class="btn-icon" @click="showSettings = !showSettings" title="Settings">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
          </div>
        </div>

        <!-- Settings Modal -->
        <div class="settings-modal" v-if="showSettings">
          <div class="settings-content">
            <h3>Settings</h3>
            <label>
              <small>OpenAI API Key</small>
              <input v-model.trim="apiKey" @change="persistApiKey" placeholder="sk-..." type="password" />
            </label>
            <label>
              <small>Renderer</small>
              <select v-model="renderModeDefault">
                <option value="shadow">Shadow DOM (recommended)</option>
                <option value="iframe">Sandboxed iframe (fallback)</option>
              </select>
            </label>
            <label>
              <small>Global Head HTML (e.g. Tailwind CDN, Fonts)</small>
              <textarea v-model.lazy="globalHeadHtml" placeholder='<script src="..."></script>' rows="3" style="font-family:monospace; font-size:11px"></textarea>
            </label>
            <button class="btn primary full" @click="showSettings = false">Done</button>
          </div>
          <div class="settings-backdrop" @click="showSettings = false"></div>
        </div>

        <div class="chat" ref="chatScroll">
          <template v-for="msg in messages">
            <div
              v-if="msg.role !== 'system' && msg.role !== 'tool'"
              :key="msg._id"
              class="bubble"
              :class="msg.role"
            >
              <div class="role">
                {{ msg.role }} <span v-if="msg.name">¬∑ {{ msg.name }}</span>
              </div>
              <div v-html="displayContent(msg)"></div>
              <div v-if="msg.images && msg.images.length" class="attachments">
                <div
                  class="thumb"
                  v-for="(img, i) in msg.images"
                  :key="img.id || i"><img :src="img.dataUrl" :alt="'attachment ' + (i + 1)" /></div>
              </div>
            </div>
          </template>
          <div v-if="assistantStreamingText" class="bubble assistant">
            <div class="role">assistant ¬∑ streaming</div>
            <div v-html="displayStreamingText"></div>
          </div>
        </div>

        <div class="input">
          <div
            class="attachments"
            v-if="inputImages.length"
            style="grid-column: 1 / -1"
          >
            <div class="thumb" v-for="img in inputImages" :key="img.id">
              <img :src="img.dataUrl" :alt="img.filename || 'image attachment'" />
              <button class="remove" @click="removeInputImage(img.id)" title="Remove">‚úï</button>
            </div>
          </div>
          <textarea
            ref="input"
            v-model="userInput"
            :disabled="isStreaming"
            @keydown.enter="handleEnter"
            @input="adjustHeight"
            @paste="onPaste"
            placeholder="Describe a design or paste an image (Ctrl/Cmd+V)‚Ä¶"
            rows="1"
          ></textarea>
          <div class="input-actions">
            <div class="model-selector">
              <select v-model="model">
                <option value="gpt-4.1">gpt-4.1 (Default)</option>
                <option value="gpt-4o">gpt-4o</option>
                <option value="gpt-4o-mini">gpt-4o-mini</option>
                <option value="gpt-4-turbo">gpt-4-turbo</option>
                <option value="gpt-4">gpt-4</option>
                <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                <option value="o1-preview">o1-preview</option>
                <option value="o1-mini">o1-mini</option>
              </select>
            </div>
            <div style="display: flex; gap: 8px">
              <button class="btn" @click="stop" :disabled="!isStreaming">
                Stop
              </button>
              <button
                class="btn primary"
                @click="send"
                :disabled="!apiKey || (!userInput && !inputImages.length) || isStreaming"
              >
                Send
              </button>
            </div>
          </div>
        </div>

      </section>

      <!-- RIGHT: Canvas -->
      <section class="right">
        <div class="canvas" ref="canvas">
          <div class="empty" v-if="!designs.length">
            <div>
              <div style="font-weight: 600; margin-bottom: 6px">
                No designs yet
              </div>
              <div class="hint">
                Describe a design in the chat to generate the first box.
              </div>
            </div>
          </div>

          <div
            v-for="d in designs"
            :key="d.id"
            class="box"
            :class="{preview: d.isPreview, fullscreen: d.isFullscreen}"
            :style="{left:d.x+'px', top:d.y+'px', width:d.width+'px', height:d.height+'px', zIndex:d.z}"
            :data-id="d.id"
            @mousedown="bringToFront(d.id)"
          >
            <div class="box-toolbar">
              <span class="actions left">
                 <button title="Undo" @click.stop="undo(d.id)" :disabled="!d.history || d.historyIndex <= 0">‚Ü∂</button>
                 <button title="Redo" @click.stop="redo(d.id)" :disabled="!d.history || d.historyIndex >= (d.history.length - 1)">‚Ü∑</button>
                 <span class="sep"></span>
                 <button title="Mobile (375px)" @click.stop="setViewport(d.id, 375)">üì±</button>
                 <button title="Tablet (768px)" @click.stop="setViewport(d.id, 768)">üíä</button>
                 <button title="Desktop (100%)" @click.stop="setViewport(d.id, 1200)">üíª</button>
              </span>
              <span class="title" @dblclick="renameDesign(d.id)"
                >{{ d.name || d.id }}</span
              >
              <span class="actions">
                <button title="Code View" @click.stop="toggleCodeView(d.id)" :class="{active: d.showCode}">
                  &lt;/&gt;
                </button>
                <button title="Duplicate" @click.stop="duplicateDesign(d.id)">
                  ‚ùê
                </button>
                <button title="Maximize" @click.stop="toggleFullscreen(d.id)">
                  ‚ßâ
                </button>
                <button title="Export HTML" @click.stop="exportHtml(d.id)">
                  ‚§ì
                </button>
                <button title="Delete" @click.stop="removeDesign(d.id)">
                  ‚úï
                </button>
              </span>
            </div>
            <div class="box-content" :ref="'box-' + d.id" v-show="!d.showCode"></div>
            <div class="box-code" v-if="d.showCode">
               <textarea v-model="d.editHtml" placeholder="HTML code..."></textarea>
               <div class="code-actions">
                 <button class="btn primary small" @click="applyCodeEdit(d.id)">Apply Changes</button>
               </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      (function () {
        const TOOLS_SPEC = [
          {
            type: "function",
            function: {
              name: "create_design",
              description: "Create a new design box and render the given HTML.",
              parameters: {
                type: "object",
                properties: {
                  name: {
                    type: "string",
                    description: "Short label for the design."
                  },
                  html: {
                    type: "string",
                    description:
                      "Self-contained HTML fragment (no external deps). MUST be non-empty with actual HTML markup. Include inline <style> tags for styling. Avoid <script> unless explicitly requested.",
                    minLength: 1
                  },
                  width: { type: "number", default: 480 },
                  height: { type: "number", default: 360 },
                  x: { type: "number", default: 40 },
                  y: { type: "number", default: 40 },
                  renderMode: {
                    type: "string",
                    enum: ["shadow", "iframe"],
                    description:
                      "Optional override of render mode for this box."
                  }
                },
                required: ["name", "html"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "edit_design",
              description:
                "Modify an existing design by providing its ID/name and the new full HTML.",
              parameters: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "The ID of the design to edit."
                  },
                  name: {
                    type: "string",
                    description:
                      "The name of the design to edit (if ID is unknown)."
                  },
                  new_html: {
                    type: "string",
                    description:
                      "The new, complete HTML to replace the entire content of the design."
                  }
                },
                required: ["new_html"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "replace_string",
              description:
                "Surgical edit: replace a substring in the HTML of a specific design.",
              parameters: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "The ID of the design to edit."
                  },
                  name: {
                    type: "string",
                    description:
                      "The name of the design to edit (if ID is unknown)."
                  },
                  old: { type: "string" },
                  new: { type: "string" },
                  occurrences: {
                    type: "string",
                    enum: ["first", "all"],
                    default: "all"
                  }
                },
                required: ["old", "new"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "list_designs",
              description: "List current designs to find their ID and name.",
              parameters: { type: "object", properties: {} }
            }
          }
        ];

        const SYSTEM_PROMPT = `
You are a UI design assistant that creates HTML designs using the create_design tool.

When the user asks to create a design, call create_design with complete HTML:
{
  "html": "<div style='padding:40px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border-radius:12px; text-align:center'><h1 style='margin:0'>Hello World</h1><p style='margin-top:10px; opacity:0.9'>This is a sample design</p></div>",
  "name": "Sample Design"
}

The html parameter must contain complete, self-contained HTML with inline styles.

For editing existing designs:
- Use list_designs() to see all designs
- Use replace_string to change specific text
- Use edit_design to replace entire HTML

After creating or editing, confirm the action in a brief chat message.
`.trim();

        // Utilities
        const uid = () => Math.random().toString(36).slice(2, 10);
        const debounce = (fn, ms = 300) => {
          let t;
          return function (...a) {
            const context = this;
            clearTimeout(t);
            t = setTimeout(() => fn.apply(context, a), ms);
          };
        };
        const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Vue app
        new Vue({
          el: "#app",
          data: () => ({
            sidebarWidth: 450,
            isResizing: false,
            showSettings: false,
            apiKey: localStorage.getItem("mini-stitch:apiKey") || "",
            model: localStorage.getItem("mini-stitch:model") || "gpt-4.1",
            renderModeDefault:
              localStorage.getItem("mini-stitch:renderModeDefault") || "shadow",
            globalHeadHtml: localStorage.getItem("mini-stitch:globalHeadHtml") || '<script src="https://cdn.tailwindcss.com"><\/script>',
            isStreaming: false,
            userInput: "",
            inputImages: [], // queued images for next user message
            assistantStreamingText: "",
            messages: [],
            designs: [],
            _interactInit: {}, // id -> true
            _abortController: null,
            _streamLoopGuard: 0, // to prevent orphan loops
            // live preview state (via partial tool args only)
            previewBoxId: "__preview__",
            // keep the latest preview HTML so we can commit even if the tool args omit `html`
            previewLastHtml: "",
            // track last active design to resolve ambiguous edits
            lastActiveDesignId: null
          }),
          created() {
            // initial system prompt
            this.ensureSystemPrompt();
            // restore saved state
            this.restoreState();
            
            // Global resize listeners
            window.addEventListener('mousemove', this.doResize);
            window.addEventListener('mouseup', this.stopResize);
          },
          destroyed() {
            window.removeEventListener('mousemove', this.doResize);
            window.removeEventListener('mouseup', this.stopResize);
          },
          mounted() {
            this.$watch(
              "designs",
              () => this.$nextTick(this.attachInteractions),
              { deep: true }
            );
          },
          methods: {
            startResize() {
              this.isResizing = true;
              document.body.style.cursor = 'col-resize';
              document.body.style.userSelect = 'none';
            },
            doResize(e) {
              if (!this.isResizing) return;
              // Constrain width
              const w = Math.max(300, Math.min(e.clientX, window.innerWidth - 300));
              this.sidebarWidth = w;
            },
            stopResize() {
              if (this.isResizing) {
                this.isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
              }
            },
            adjustHeight() {
              const el = this.$refs.input;
              if (!el) return;
              el.style.height = "auto";
              el.style.height = el.scrollHeight + "px";
            },
            handleEnter(e) {
              if (e.shiftKey) return;
              e.preventDefault();
              this.send();
            },
            renderMarkdown(text) {
              if (!text) return "";
              if (typeof marked === "undefined") return text;
              return DOMPurify.sanitize(marked.parse(text));
            },
            displayContent(msg) {
              // For messages with content, display it
              if (msg.content && msg.content.trim()) {
                return this.renderMarkdown(msg.content);
              }
              // For tool-only messages (e.g., assistant with only tool_calls), show indicator
              if (msg.tool_calls && msg.tool_calls.length > 0) {
                const toolNames = msg.tool_calls
                  .map(tc => tc.function?.name || "unknown")
                  .join(", ");
                return `<em style="color:var(--muted)">Calling tools: ${toolNames}...</em>`;
              }
              // Empty message
              return "";
            },

            ensureSystemPrompt() {
              if (!this.messages.length || this.messages[0].role !== "system") {
                this.messages.unshift({
                  _id: uid(),
                  role: "system",
                  content: SYSTEM_PROMPT
                });
              }
            },
            saveState: debounce(function () {
              try {
                // IMPORTANT: Do NOT persist base64 images in chat history; they easily exceed localStorage.
                const messagesToSave = this.messages.map(m => {
                  const copy = Object.assign({}, m);
                  if (copy.images) {
                    // Drop images on persistence to keep storage small.
                    delete copy.images;
                  }
                  return copy;
                });
                localStorage.setItem(
                  "mini-stitch:messages",
                  JSON.stringify(messagesToSave)
                );
                localStorage.setItem(
                  "mini-stitch:designs",
                  JSON.stringify(
                    this.designs
                      .map(d => {
                        // Don't save renderer instances or preview boxes
                        const { _renderer, isPreview, ...rest } = d;
                        return isPreview ? null : rest;
                      })
                      .filter(Boolean)
                  )
                );
              } catch (e) {
                console.warn("Failed to save state:", e);
              }
            }, 500),
            restoreState() {
              try {
                const savedMessages = localStorage.getItem(
                  "mini-stitch:messages"
                );
                if (savedMessages) {
                  const parsed = JSON.parse(savedMessages);
                  if (Array.isArray(parsed) && parsed.length > 0) {
                    this.messages = parsed;
                  }
                }

                const savedDesigns = localStorage.getItem(
                  "mini-stitch:designs"
                );
                if (savedDesigns) {
                  const parsed = JSON.parse(savedDesigns);
                  if (Array.isArray(parsed) && parsed.length > 0) {
                    this.designs = parsed;
                    this.$nextTick(() => {
                      this.designs.forEach(d => this.renderDesign(d));
                    });
                  }
                }
              } catch (e) {
                console.warn("Failed to restore state:", e);
              }
            },
            persistApiKey() {
              localStorage.setItem("mini-stitch:apiKey", this.apiKey || "");
            },
            persistModel() {
              localStorage.setItem("mini-stitch:model", this.model || "");
            },
            persistRenderModeDefault() {
              localStorage.setItem(
                "mini-stitch:renderModeDefault",
                this.renderModeDefault || "shadow"
              );
            },

            // ===== Canvas helpers =====
            bringToFront(id) {
              const top = Math.max(0, ...this.designs.map(d => d.z || 0)) + 1;
              const d = this.getDesign(id);
              if (!d) return;
              Vue.set(d, "z", top);
              this.lastActiveDesignId = id;
            },
            renameDesign(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const name = prompt("New name for design:", d.name || "");
              if (name !== null) {
                d.name = name.trim();
              }
            },
            toggleFullscreen(id) {
              const d = this.getDesign(id);
              if (!d) return;
              Vue.set(d, "isFullscreen", !d.isFullscreen);
            },
            duplicateDesign(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const copy = JSON.parse(JSON.stringify(d));
              copy.id = uid();
              copy.name = (d.name || d.id) + " copy";
              copy.x += 20;
              copy.y += 20;
              copy.z = Math.max(...this.designs.map(x => x.z || 0)) + 1;
              copy.isPreview = false;
              this.designs.push(copy);
              this.$nextTick(() => this.renderDesign(copy));
              this.lastActiveDesignId = copy.id;
            },
            removeDesign(id) {
              const idx = this.designs.findIndex(d => d.id === id);
              if (idx >= 0) this.designs.splice(idx, 1);
            },
            getDesign(id) {
              return this.designs.find(d => d.id === id);
            },
            getDesignByName(name) {
              if (!name) return null;
              const n = String(name).trim().toLowerCase();
              return (
                this.designs.find(
                  d => (d.name || "").trim().toLowerCase() === n
                ) || null
              );
            },
            resolveDesignId(args) {
              // Priority: explicit id -> explicit name -> last active -> only design (if exactly 1)
              if (args && typeof args.id === "string" && args.id.trim())
                return args.id.trim();
              if (args && typeof args.name === "string") {
                const byName = this.getDesignByName(args.name);
                if (byName) return byName.id;
              }
              if (
                this.lastActiveDesignId &&
                this.getDesign(this.lastActiveDesignId)
              ) {
                return this.lastActiveDesignId;
              }
              if (this.designs.length === 1) return this.designs[0].id;
              return null;
            },
            listDesignsToChat() {
              const list = this.designs.map(d => ({
                id: d.id,
                name: d.name,
                size: { w: d.width, h: d.height },
                position: { x: d.x, y: d.y },
                updatedAt: d.updatedAt || d.createdAt
              }));
              this.messages.push({
                _id: uid(),
                role: "tool",
                name: "list_designs",
                content: JSON.stringify(list, null, 2)
              });
            },

            // ===== Rendering & isolation =====
            // ===== History & Viewport =====
            pushHistory(d) {
              if (!d.history) {
                this.$set(d, 'history', []);
                this.$set(d, 'historyIndex', -1);
              }
              // If we are not at the end, truncate future
              if (d.historyIndex < d.history.length - 1) {
                d.history = d.history.slice(0, d.historyIndex + 1);
              }
              d.history.push(d.html);
              d.historyIndex = d.history.length - 1;
            },
            undo(id) {
              const d = this.getDesign(id);
              if (!d || !d.history || d.historyIndex <= 0) return;
              d.historyIndex--;
              d.html = d.history[d.historyIndex];
              this.renderDesign(d);
            },
            redo(id) {
              const d = this.getDesign(id);
              if (!d || !d.history || d.historyIndex >= d.history.length - 1) return;
              d.historyIndex++;
              d.html = d.history[d.historyIndex];
              this.renderDesign(d);
            },
            setViewport(id, width) {
              const d = this.getDesign(id);
              if (!d) return;
              d.width = width;
              // Trigger resize logic if needed, or just let Vue binding handle it
            },
            toggleCodeView(id) {
              const d = this.getDesign(id);
              if (!d) return;
              this.$set(d, 'showCode', !d.showCode);
              if (d.showCode) {
                this.$set(d, 'editHtml', d.html);
              }
            },
            applyCodeEdit(id) {
              const d = this.getDesign(id);
              if (!d) return;
              if (d.editHtml !== d.html) {
                d.html = d.editHtml;
                this.pushHistory(d);
                this.renderDesign(d);
              }
              d.showCode = false;
            },
            duplicateDesign(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const newD = JSON.parse(JSON.stringify(d));
              newD.id = uid();
              newD.name = d.name + " (Copy)";
              newD.x += 20;
              newD.y += 20;
              newD.z = Math.max(0, ...this.designs.map(x => x.z || 0)) + 1;
              // Reset history for copy
              newD.history = [newD.html];
              newD.historyIndex = 0;
              this.designs.push(newD);
              this.$nextTick(() => this.renderDesign(newD));
            },

            // ===== Render Logic =====
            sanitize(html) {
              return DOMPurify.sanitize(html, {
                USE_PROFILES: { html: true },
                FORBID_TAGS: ["script", "iframe", "object", "embed", "link"]
                // DOMPurify by default strips event handlers (on*) and JS URLs.
              });
            },
            renderDesign(design) {
              const host = this.$refs["box-" + design.id];
              const el = Array.isArray(host) ? host[0] : host;
              if (!el) return;

              const sanitized = this.sanitize(design.html || "<div></div>");

              // Choose renderer
              const mode =
                design.renderMode || this.renderModeDefault || "shadow";
              
              // Prepend global head HTML
              const fullHtml = (this.globalHeadHtml || "") + sanitized;

              if (mode === "iframe") {
                // sandboxed iframe (we control only from parent)
                el.innerHTML = "";
                const ifr = document.createElement("iframe");
                ifr.setAttribute("sandbox", "allow-scripts");
                ifr.style.border = "0";
                ifr.style.width = "100%";
                ifr.style.height = "100%";
                // Ensure dark-ish background inside
                const html = `
<!doctype html><html><head><meta charset="utf-8">
<style>html,body{height:100%;margin:0;background:#0b1220;color:#e5e7eb}</style>
</head><body>${fullHtml}</body></html>`;
                ifr.srcdoc = html;
                el.appendChild(ifr);
                design._renderer = { mode: "iframe", node: ifr };
                return;
              }

              // Shadow DOM (open so we can update it)
              if (!el.shadowRoot) el.attachShadow({ mode: "open" });
              el.shadowRoot.innerHTML = fullHtml;
              design._renderer = { mode: "shadow", node: el.shadowRoot };
            },
            ensurePreviewBox() {
              let d = this.getDesign(this.previewBoxId);
              if (!d) {
                const cx = 100,
                  cy = 80;
                d = {
                  id: this.previewBoxId,
                  name: "Preview",
                  isPreview: true,
                  html: '<div style="padding:16px;font:14px system-ui;color:#94a3b8">Generating preview‚Ä¶</div>',
                  x: cx,
                  y: cy,
                  width: 560,
                  height: 420,
                  z: Math.max(0, ...this.designs.map(x => x.z || 0)) + 1,
                  createdAt: Date.now(),
                  updatedAt: Date.now(),
                  renderMode: this.renderModeDefault
                };
                this.designs.push(d);
                this.$nextTick(() => this.renderDesign(d));
              }
              return d;
            },
            updatePreviewHtml(html) {
              const d = this.ensurePreviewBox();
              d.html = html;
              d.updatedAt = Date.now();
              // remember latest preview html for commit fallback
              this.previewLastHtml = html;
              this.pushHistory(d); // Track preview history too? Maybe too noisy. Let's track it.
              this.$nextTick(() => this.renderDesign(d));
            },
            clearPreview() {
              const idx = this.designs.findIndex(
                d => d.id === this.previewBoxId
              );
              if (idx >= 0) this.designs.splice(idx, 1);
            },

            // ===== Interactions =====
            attachInteractions() {
              // Ensure _interactInit is initialized
              if (!this._interactInit) {
                this._interactInit = {};
              }

              // attach interact.js to each box once
              this.designs.forEach(d => {
                if (this._interactInit[d.id]) return;
                this._interactInit[d.id] = true;

                const selector = `.box[data-id="${d.id}"]`;
                interact(selector)
                  .draggable({
                    listeners: {
                      move: event => {
                        const id = event.target.dataset.id;
                        const dd = this.getDesign(id);
                        if (!dd) return;
                        dd.x += event.dx;
                        dd.y += event.dy;
                        event.target.style.left = dd.x + "px";
                        event.target.style.top = dd.y + "px";
                      }
                    },
                    inertia: false
                  })
                  .resizable({
                    edges: { left: true, right: true, bottom: true, top: true },
                    listeners: {
                      move: event => {
                        const id = event.target.dataset.id;
                        const dd = this.getDesign(id);
                        if (!dd) return;
                        dd.width = event.rect.width;
                        dd.height = event.rect.height;
                        dd.x += event.deltaRect.left;
                        dd.y += event.deltaRect.top;
                        const style = event.target.style;
                        style.width = dd.width + "px";
                        style.height = dd.height + "px";
                        style.left = dd.x + "px";
                        style.top = dd.y + "px";
                      }
                    }
                  });
              });
            },

            // ===== OpenAI chat orchestration =====

            // Handle clipboard images ------------------------------------------------
            async onPaste(e) {
              try {
                const items = Array.from(e.clipboardData?.items || []);
                const imageItems = items.filter(
                  it => it.kind === "file" && it.type && it.type.startsWith("image/")
                );
                if (!imageItems.length) return; // let normal text paste happen
                e.preventDefault();

                // API limit: up to 10 images per request (keep composer aligned)
                const remaining = Math.max(0, 10 - this.inputImages.length);
                for (const it of imageItems.slice(0, remaining)) {
                  const file = it.getAsFile();
                  if (file) await this.addInputImageFromFile(file);
                }
              } catch (err) {
                console.warn("Paste handling failed:", err);
              }
            },

            async addInputImageFromFile(file) {
              const processed = await this.downscaleImage(file, 1600);
              if (!processed) return;
              this.inputImages.push({
                id: uid(),
                filename: file.name || "",
                ...processed
              });
            },

            // Downscale & JPEG‚Äëencode to keep payloads small
            downscaleImage(file, maxDim = 1600) {
              return new Promise(resolve => {
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                  let w = img.naturalWidth || img.width || 1;
                  let h = img.naturalHeight || img.height || 1;
                  const scale = Math.min(1, maxDim / Math.max(w, h));
                  const nw = Math.max(1, Math.round(w * scale));
                  const nh = Math.max(1, Math.round(h * scale));
                  const canvas = document.createElement("canvas");
                  canvas.width = nw;
                  canvas.height = nh;
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(img, 0, 0, nw, nh);
                  // Prefer JPEG for size; quality tuned for legibility
                  const dataUrl = canvas.toDataURL("image/jpeg", 0.85);
                  const sizeBytes = Math.ceil(
                    (dataUrl.length - (dataUrl.indexOf(",") + 1)) * 3 / 4
                  );
                  URL.revokeObjectURL(url);
                  resolve({
                    dataUrl,
                    mime: "image/jpeg",
                    width: nw,
                    height: nh,
                    sizeBytes
                  });
                };
                img.onerror = () => {
                  URL.revokeObjectURL(url);
                  resolve(null);
                };
                img.src = url;
              });
            },

            removeInputImage(id) {
              const idx = this.inputImages.findIndex(x => x.id === id);
              if (idx >= 0) this.inputImages.splice(idx, 1);
            },

            async send() {
              if (!this.apiKey) {
                alert("Provide an OpenAI API key first.");
                return;
              }
              if (!this.apiKey.startsWith("sk-")) {
                alert(
                  "Invalid API key format. OpenAI API keys should start with 'sk-'"
                );
                return;
              }
              const text = this.userInput.trim();
              const hasImages = this.inputImages && this.inputImages.length > 0;
              if (!text && !hasImages) return;

              this.ensureSystemPrompt();
              const userMsg = { _id: uid(), role: "user", content: text };
              if (hasImages) {
                userMsg.images = this.inputImages.map(img => ({
                  id: img.id,
                  dataUrl: img.dataUrl,
                  mime: img.mime,
                  width: img.width,
                  height: img.height,
                  sizeBytes: img.sizeBytes
                }));
              }
              this.messages.push(userMsg);
              this.userInput = "";
              this.inputImages = [];

              try {
                this.isStreaming = true;
                await this.chatLoop();
              } catch (e) {
                if (
                  e &&
                  (e.name === "AbortError" || String(e).includes("AbortError"))
                ) {
                  console.debug("Streaming aborted by user.");
                } else {
                  console.error("Request failed:", e);
                  let errorMsg = "Request failed. ";
                  if (e.message && e.message.includes("Failed to fetch")) {
                    errorMsg +=
                      "Network error - check your internet connection or CORS settings.";
                  } else if (e.message && e.message.includes("401")) {
                    errorMsg += "Invalid API key.";
                  } else if (e.message && e.message.includes("429")) {
                    errorMsg += "Rate limit exceeded.";
                  } else {
                    errorMsg += "See console for details.";
                  }
                  alert(errorMsg);
                }
              } finally {
                this.isStreaming = false;
                this.assistantStreamingText = "";
                this.clearPreview(); // remove any orphan preview when done
                this._abortController = null;
                this.$nextTick(() => {
                  if (this.$refs.input) {
                    this.$refs.input.focus();
                    this.adjustHeight();
                  }
                });
              }
            },
            stop() {
              if (this._abortController) this._abortController.abort();
            },

            async chatLoop() {
              if (
                typeof this._streamLoopGuard !== "number" ||
                isNaN(this._streamLoopGuard)
              ) {
                this._streamLoopGuard = 0;
              }

              let continueLoop = true;
              let loopGuard = ++this._streamLoopGuard;
              let iteration = 0;
              let requireToolThisTurn = false; // Don't force tools - let model decide when ready
              const MAX_TOOL_ROUNDS = 6;

              while (continueLoop && loopGuard === this._streamLoopGuard) {
                iteration++;
                if (iteration > MAX_TOOL_ROUNDS) {
                  console.warn("Max tool rounds reached; aborting turn.");
                  break;
                }
                const result = await this.streamOnce({
                  toolChoice: requireToolThisTurn ? "required" : "auto"
                });

                if (result.toolCalls && result.toolCalls.length) {
                  let mutationSucceeded = false;
                  for (const call of result.toolCalls) {
                    const toolResult = await this.executeToolCall(
                      call.name,
                      call.args,
                      call.id
                    );
                    this.messages.push({
                      _id: uid(),
                      role: "tool",
                      name: call.name,
                      tool_call_id: call.id,
                      content: JSON.stringify(toolResult)
                    });
                    // Count ANY successful tool call as progress (not just mutations)
                    // This prevents infinite loops when model uses list_designs or other info tools
                    if (toolResult && !toolResult.error) {
                      mutationSucceeded = true;
                    }
                  }
                  // NEVER force tools - always let model decide
                  // This allows the model to respond with text after errors instead of being stuck in a tool-calling loop
                  requireToolThisTurn = false;
                  continueLoop = true;
                } else {
                  continueLoop = false;
                }
              }
            },

            async streamOnce(opts = {}) {
              this.assistantStreamingText = "";
              const toolBuffers = {}; // id -> { name, argsText }
              const indexToId = {}; // Map tool call index to its id
              const toolCalls = [];
              let assistantMessagePushed = false;
              let assistantMessage = {
                _id: uid(),
                role: "assistant",
                content: ""
              };

              const url = "https://api.openai.com/v1/chat/completions";
              const headers = {
                "Content-Type": "application/json",
                Authorization: "Bearer " + this.apiKey
              };

              const requestPayload = {
                model: this.model,
                stream: true,
                messages: this.messages.map(m => {
                  const { role, content, name, tool_call_id, tool_calls } = m;
                  const out = { role };

                  // If user message has images, build a multimodal content array
                  if (role === "user" && Array.isArray(m.images) && m.images.length > 0) {
                    const parts = [];
                    if (typeof content === "string" && content.trim()) {
                      parts.push({ type: "text", text: content });
                    }
                    for (const img of m.images) {
                      parts.push({
                        type: "image_url",
                        image_url: { url: img.dataUrl } // 'detail' defaults to 'auto'
                      });
                    }
                    out.content = parts;
                  } else if (content !== undefined) {
                    out.content = content;
                  }
                  if (name !== undefined) out.name = name;
                  if (tool_call_id !== undefined)
                    out.tool_call_id = tool_call_id;
                  if (tool_calls !== undefined) out.tool_calls = tool_calls;
                  return out;
                }),
                tools: TOOLS_SPEC,
                tool_choice: opts.toolChoice || "auto"
              };

              // DEBUG: Log the full request to see what we're sending to OpenAI
              console.log("[REQUEST] Sending to OpenAI:", {
                model: requestPayload.model,
                tool_choice: requestPayload.tool_choice,
                messageCount: requestPayload.messages.length,
                lastThreeMessages: requestPayload.messages.slice(-3).map(m => ({
                  role: m.role,
                  contentPreview: m.content
                    ? (typeof m.content === "string"
                        ? m.content.substring(0, 100)
                        : Array.isArray(m.content)
                          ? `[multimodal: ${m.content.length} parts]`
                          : "(complex content)")
                    : "(no content)",
                  hasToolCalls: !!m.tool_calls,
                  name: m.name
                }))
              });

              const body = JSON.stringify(requestPayload);
              const controller = new AbortController();
              this._abortController = controller;

              let res;
              try {
                res = await fetch(url, {
                  method: "POST",
                  headers,
                  body,
                  signal: controller.signal
                });
              } catch (fetchError) {
                console.error("Fetch failed:", fetchError);
                throw fetchError;
              }

              if (!res.ok || !res.body) {
                const err = await res.text().catch(() => String(res.status));
                console.error("OpenAI API error:", {
                  status: res.status,
                  statusText: res.statusText,
                  errorBody: err
                });
                throw new Error("OpenAI error: " + err);
              }

              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let buffer = "";

              const pushAssistantIfNeeded = () => {
                if (
                  !assistantMessagePushed &&
                  (assistantMessage.content.trim() ||
                    (assistantMessage.tool_calls &&
                      assistantMessage.tool_calls.length > 0))
                ) {
                  this.messages.push(assistantMessage);
                  assistantMessagePushed = true;
                }
              };

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                const lines = buffer.split("\n");
                buffer = lines.pop();

                for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed.startsWith("data:")) continue;
                  const data = trimmed.slice(5).trim();
                  if (data === "[DONE]") continue;

                  let evt;
                  try {
                    evt = JSON.parse(data);
                  } catch {
                    continue;
                  }
                  const choice = evt.choices && evt.choices[0];
                  if (!choice) continue;

                  const delta = choice.delta || {};
                  const finish = choice.finish_reason;

                  if (delta.content) {
                    assistantMessage.content += delta.content;
                    this.assistantStreamingText += delta.content;
                    this.scrollChatToEndSoon();
                  }

                  if (Array.isArray(delta.tool_calls)) {
                    for (const t of delta.tool_calls) {
                      console.log(
                        "[STREAM DELTA] tool_call chunk:",
                        JSON.stringify(t)
                      );

                      // Track index->id mapping when id first appears
                      if (t.id && t.index !== undefined) {
                        indexToId[t.index] = t.id;
                      }

                      // Use the tracked id for this index, or the id from this chunk
                      const toolId = indexToId[t.index] || t.id;

                      if (!toolId) {
                        console.warn(
                          "[STREAM DELTA] No id available for index",
                          t.index
                        );
                        continue;
                      }

                      if (!toolBuffers[toolId]) {
                        toolBuffers[toolId] = {
                          id: toolId,
                          name: t.function?.name || "",
                          argsText: ""
                        };
                      }

                      if (t.function?.name)
                        toolBuffers[toolId].name = t.function.name;
                      if (toolBuffers[toolId].name === "create_design") {
                        this.ensurePreviewBox();
                      }
                      if (t.function?.arguments) {
                        console.log(
                          "[STREAM DELTA] Appending arguments chunk:",
                          t.function.arguments
                        );
                        toolBuffers[toolId].argsText += t.function.arguments;
                        if (toolBuffers[toolId].name === "create_design") {
                          const partialHtml = this.extractPartialJsonString(
                            toolBuffers[toolId].argsText,
                            "html"
                          );
                          if (partialHtml) this.updatePreviewHtml(partialHtml);
                        }
                      }
                    }
                  }

                  if (finish === "tool_calls") {
                    const callsForMsg = Object.entries(toolBuffers)
                      .filter(
                        ([key, buf]) => buf.name && buf.name.trim() && buf.id
                      )
                      .map(([key, buf]) => ({
                        id: buf.id,
                        type: "function",
                        function: {
                          name: buf.name,
                          arguments: buf.argsText || "{}"
                        }
                      }));

                    if (callsForMsg.length > 0) {
                      assistantMessage.tool_calls = callsForMsg;
                    }

                    for (const [key, buf] of Object.entries(toolBuffers)) {
                      if (!buf.name || !buf.name.trim()) {
                        console.warn(
                          "Skipping tool call with empty name:",
                          key
                        );
                        continue;
                      }
                      if (!buf.id) {
                        console.warn("Skipping tool call without id:", key);
                        continue;
                      }

                      // DEBUG: Log what OpenAI actually sent
                      console.log(
                        `[STREAM] Tool: ${buf.name}, argsText length: ${buf.argsText.length}`
                      );
                      console.log(`[STREAM] argsText content: ${buf.argsText}`);

                      let args = {};
                      try {
                        args = JSON.parse(buf.argsText || "{}");
                        console.log("[STREAM] Parsed args:", args);
                      } catch (e) {
                        console.warn(
                          "Failed to parse tool args JSON, using fallback extraction:",
                          buf.argsText.substring(0, 100)
                        );
                        // Fallback: try to extract partial JSON fields
                        try {
                          const html = this.extractPartialJsonString(
                            buf.argsText,
                            "html"
                          );
                          if (html) args.html = html;
                          const name = this.extractPartialJsonString(
                            buf.argsText,
                            "name"
                          );
                          if (name) args.name = name;
                        } catch (extractError) {
                          console.warn(
                            "Partial extraction also failed, using empty args"
                          );
                        }
                      }
                      toolCalls.push({ id: buf.id, name: buf.name, args });
                    }
                  }
                }
              }
              pushAssistantIfNeeded();
              return { toolCalls };
            },

            // ===== Tool executors =====
            async executeToolCall(name, args, toolCallId) {
              try {
                if (name === "create_design")
                  return this.tool_create_design(args);
                if (name === "edit_design") return this.tool_edit_design(args);
                if (name === "replace_string")
                  return this.tool_replace_string(args);
                if (name === "list_designs") return this.tool_list_designs();
                return { error: "Unknown tool: " + name };
              } catch (e) {
                console.error("Tool error", name, e);
                return { error: String(e) };
              }
            },

            tool_create_design(args) {
              console.log("[CREATE_DESIGN] Called with args:", args);

              // STRICT VALIDATION: Return error if html is missing or empty
              // This forces the model to retry with proper HTML
              let html = typeof args.html === "string" ? args.html.trim() : "";
              console.log("[CREATE_DESIGN] HTML length:", html.length);

              if (!html) {
                console.error(
                  "[CREATE_DESIGN] ERROR: html parameter is required but was empty/missing"
                );
                return {
                  error: "missing_html",
                  message:
                    "CRITICAL: The 'html' parameter is REQUIRED and must contain actual HTML markup. You called create_design with empty or missing html. Example of correct call: create_design({html: \"<div style='padding:20px'>Hello World</div>\", name: \"MyDesign\"}). Please retry with proper HTML content."
                };
              }

              const id = uid();
              const d = {
                id,
                name: (args.name || "Untitled").toString().slice(0, 80),
                html: html,
                x: Number.isFinite(args.x) ? args.x : 40,
                y: Number.isFinite(args.y) ? args.y : 40,
                width: Number.isFinite(args.width) ? args.width : 560,
                height: Number.isFinite(args.height) ? args.height : 420,
                z: Math.max(0, ...this.designs.map(x => x.z || 0)) + 1,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                renderMode: args.renderMode || this.renderModeDefault
              };

              const previewIdx = this.designs.findIndex(
                x => x.id === this.previewBoxId
              );
              if (previewIdx >= 0) {
                const preview = this.designs[previewIdx];
                d.x = preview.x;
                d.y = preview.y;
                d.width = preview.width;
                d.height = preview.height;
                d.z = preview.z;
                this.designs.splice(previewIdx, 1, d);
                console.log(
                  "[CREATE_DESIGN] Replaced preview box with design, id:",
                  d.id
                );
              } else {
                this.designs.push(d);
                console.log(
                  "[CREATE_DESIGN] Added new design to array, id:",
                  d.id
                );
              }

              console.log(
                "[CREATE_DESIGN] Total designs now:",
                this.designs.length
              );
              console.log("[CREATE_DESIGN] Calling renderDesign...");
              this.$nextTick(() => this.renderDesign(d));
              this.previewLastHtml = "";
              this.lastActiveDesignId = d.id;
              console.log("[CREATE_DESIGN] Returning success:", {
                id: d.id,
                name: d.name
              });
              return { id: d.id, name: d.name };
            },

            tool_edit_design(args) {
              const resolvedId = this.resolveDesignId(args);
              if (!resolvedId) {
                return {
                  error: "design_not_found",
                  message:
                    "You must specify the 'id' or 'name' of the design to modify. Use list_designs() if you are unsure."
                };
              }
              const d = this.getDesign(resolvedId);
              if (!d)
                return {
                  error: "Design not found with resolved id: " + resolvedId
                };

              if (typeof args.new_html === "string" && args.new_html.trim()) {
                d.html = args.new_html;
                d.updatedAt = Date.now();
                this.$nextTick(() => this.renderDesign(d));
                this.lastActiveDesignId = d.id;
                return { id: d.id, status: "updated" };
              }

              return {
                error: "missing_parameters",
                message:
                  "edit_design requires the 'new_html' parameter with the full HTML content.",
                id: d.id
              };
            },

            tool_replace_string(args) {
              const resolvedId = this.resolveDesignId(args);
              if (!resolvedId) {
                return {
                  error: "design_not_found",
                  message:
                    "You must specify the 'id' or 'name' of the design to modify. Use list_designs() if you are unsure."
                };
              }
              const d = this.getDesign(resolvedId);
              if (!d)
                return {
                  error: "Design not found with resolved id: " + resolvedId
                };

              const oldS = String(args.old || "");
              const newS = String(args.new || "");
              if (!oldS)
                return {
                  error: "The 'old' string to be replaced cannot be empty."
                };

              let replacedCount = 0;
              if (args.occurrences === "first") {
                const idx = d.html.indexOf(oldS);
                if (idx !== -1) {
                  d.html =
                    d.html.slice(0, idx) +
                    newS +
                    d.html.slice(idx + oldS.length);
                  replacedCount = 1;
                }
              } else {
                const re = new RegExp(escapeRegExp(oldS), "g");
                replacedCount = (d.html.match(re) || []).length;
                d.html = d.html.replace(re, newS);
              }

              d.updatedAt = Date.now();
              this.$nextTick(() => this.renderDesign(d));
              this.lastActiveDesignId = d.id;
              return { id: d.id, replacedCount };
            },

            tool_list_designs() {
              const list = this.designs.map(d => ({
                id: d.id,
                name: d.name,
                size: { w: d.width, h: d.height },
                position: { x: d.x, y: d.y },
                z: d.z,
                updatedAt: d.updatedAt
              }));
              return list;
            },

            // ===== Preview helpers =====
            extractPartialJsonString(buf, field) {
              const key = `"${field}"`;
              const k = buf.indexOf(key);
              if (k === -1) return null;
              let i = buf.indexOf(":", k);
              if (i === -1) return null;
              while (i + 1 < buf.length && /\s/.test(buf[i + 1])) i++;
              if (buf[i + 1] !== '"') return null;
              let j = i + 2,
                out = "",
                esc = false;
              for (; j < buf.length; j++) {
                const ch = buf[j];
                if (esc) {
                  if (ch === "n") out += "\n";
                  else if (ch === "t") out += "\t";
                  else if (ch === "r") {
                    /* ignore */
                  } else out += ch;
                  esc = false;
                } else {
                  if (ch === "\\") esc = true;
                  else if (ch === '"') {
                    break;
                  } else out += ch;
                }
              }
              return out;
            },

            // ===== Misc =====
            scrollChatToEndSoon: debounce(function () {
              const el = this.$refs.chatScroll;
              if (el) el.scrollTop = el.scrollHeight;
            }, 40),
            clearChat() {
              if (!confirm("Clear chat history? (Designs will be kept)"))
                return;
              this.messages = [
                { _id: uid(), role: "system", content: SYSTEM_PROMPT }
              ];
            },
            newCanvas() {
              if (
                !confirm(
                  "Clear canvas and chat history (except system prompt)?"
                )
              )
                return;
              this.designs = [];
              this.messages = [
                { _id: uid(), role: "system", content: SYSTEM_PROMPT }
              ];
            },
            exportHtml(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const sanitized = this.sanitize(d.html);
              const blob = new Blob([sanitized], { type: "text/html" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = (d.name || d.id).replace(/[^\w.-]+/g, "_") + ".html";
              document.body.appendChild(a);
              a.click();
              setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
              }, 100);
            }
          },
          computed: {
            displayStreamingText() {
              return this.renderMarkdown(this.assistantStreamingText || "");
            }
          },
          watch: {
            apiKey() {
              this.persistApiKey();
            },
            model() {
              this.persistModel();
            },
            renderModeDefault() {
              this.persistRenderModeDefault();
            },
            globalHeadHtml() {
              localStorage.setItem("mini-stitch:globalHeadHtml", this.globalHeadHtml);
              // Re-render all designs to apply changes
              this.designs.forEach(d => this.renderDesign(d));
            },
            messages: {
              handler() {
                this.saveState();
              },
              deep: true
            },
            designs: {
              handler() {
                this.saveState();
              },
              deep: true
            }
          }
        });
      })();
    </script>

    <!-- SECURITY NOTE:
This is a client-only demo. Do NOT deploy with a long-lived API key.
For production, issue short-lived ephemeral tokens from a tiny server. -->
  </body>
</html>
