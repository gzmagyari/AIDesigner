<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Mini Stitch – AI Design Canvas (Vue2 + OpenAI)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      [v-cloak] {
        display: none;
      }
      :root {
        --bg: #0b1220;
        --panel: #0f172a;
        --panel-2: #0b1220;
        --border: #1f2937;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #60a5fa;
        --white: #ffffff;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        height: 100vh;
      }
      .left {
        display: grid;
        grid-template-rows: auto 1fr auto;
        border-right: 1px solid var(--border);
        background: var(--panel);
        overflow: hidden;
      }
      .toolbar {
        padding: 12px;
        border-bottom: 1px solid var(--border);
        display: grid;
        gap: 8px;
      }
      .toolbar .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .toolbar input,
      .toolbar select,
      .toolbar textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #0b1220;
        color: var(--text);
        outline: none;
      }
      .toolbar small {
        color: var(--muted);
        display: block;
      }
      .toolbar .buttons {
        display: flex;
        gap: 8px;
      }
      .btn {
        background: #111827;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .btn.primary {
        background: #1d4ed8;
        border-color: #1d4ed8;
      }
      .btn.ghost {
        background: transparent;
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .chat {
        overflow-y: auto;
        overflow-x: hidden;
        padding: 12px;
        min-height: 0;
      }
      .bubble {
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        margin-bottom: 10px;
        background: #0b1220;
        white-space: pre-wrap;
      }
      .bubble.assistant {
        background: #0f172a;
      }
      .bubble.tool {
        background: #0a1717;
        color: #9fe8e0;
      }
      .role {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .input {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        padding: 12px;
        border-top: 1px solid var(--border);
        background: var(--panel);
      }
      .input input {
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #0b1220;
        color: var(--text);
      }
      .right {
        position: relative;
        background: radial-gradient(
          1200px 600px at 30% -10%,
          rgba(96, 165, 250, 0.15),
          transparent 60%
        );
      }
      .canvas {
        position: absolute;
        inset: 0;
        overflow: auto;
        padding: 24px;
      }
      .box {
        position: absolute;
        background: #0b1220;
        border: 1px solid var(--border);
        border-radius: 12px;
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
        overflow: hidden;
        user-select: none;
      }
      .box-toolbar {
        height: 34px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        background: #0f172a;
        border-bottom: 1px solid var(--border);
        font-size: 12px;
      }
      .box-toolbar .title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .box-toolbar .actions button {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 6px;
        padding: 4px 6px;
        margin-left: 6px;
        cursor: pointer;
      }
      .box-toolbar .actions button:hover {
        border-color: #2b3647;
      }
      .box-content {
        position: absolute;
        inset: 34px 0 0 0;
        background: #0b1220;
        overflow: auto;
      }
      .box.preview {
        border-style: dashed;
      }
      .box.fullscreen {
        position: absolute !important;
        inset: 24px !important;
        left: 24px !important;
        top: 24px !important;
        right: 24px !important;
        bottom: 24px !important;
        width: auto !important;
        height: auto !important;
        z-index: 9999 !important;
      }
      .empty {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #94a3b8;
        font-size: 14px;
        text-align: center;
        padding: 20px;
      }
      .hint {
        color: #9ca3af;
        font-size: 12px;
      }
      .pill {
        padding: 2px 8px;
        border-radius: 99px;
        border: 1px solid var(--border);
        color: var(--muted);
      }

      /* Attachments (used in chat bubbles and composer) */
      .attachments {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }
      .thumb {
        position: relative;
        width: 64px;
        height: 64px;
        border: 1px solid var(--border);
        border-radius: 8px;
        overflow: hidden;
        background: #0b1220;
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .thumb .remove {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 20px;
        height: 20px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #111827;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .input .attachments { grid-column: 1 / -1; }
    </style>

    <!-- CDN libs -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  </head>
  <body>
    <div id="app" class="app" v-cloak>
      <!-- LEFT: Controls & Chat -->
      <section class="left">
        <div class="toolbar">
          <div class="row">
            <label>
              <small>OpenAI API key (stored locally, dev only)</small>
              <input
                v-model.trim="apiKey"
                @change="persistApiKey"
                placeholder="sk-..."
              />
            </label>
            <label>
              <small>Model (supports tool calls + streaming)</small>
              <input v-model.trim="model" list="model-suggestions" />
              <datalist id="model-suggestions">
                <option>gpt-4o-mini</option>
                <option>gpt-4o</option>
                <option>gpt-4.1-mini</option>
              </datalist>
            </label>
            <label>
              <small>Renderer</small>
              <select v-model="renderModeDefault">
                <option value="shadow">Shadow DOM (recommended)</option>
                <option value="iframe">Sandboxed iframe (fallback)</option>
              </select>
            </label>
          </div>
          <div class="buttons">
            <button class="btn ghost" @click="clearChat()">Clear chat</button>
            <button class="btn ghost" @click="newCanvas()">New canvas</button>
            <button class="btn ghost" @click="listDesignsToChat()">
              List designs
            </button>
          </div>
          <small class="hint"
            >Tip: Ask “Create a hero section card with a headline + CTA”. Then
            try “Replace ‘Get Started’ with ‘Try it free’ in Hero”.</small
          >
        </div>

        <div class="chat" ref="chatScroll">
          <template v-for="msg in messages">
            <div
              v-if="msg.role !== 'system' && msg.role !== 'tool'"
              :key="msg._id"
              class="bubble"
              :class="msg.role"
            >
              <div class="role">
                {{ msg.role }} <span v-if="msg.name">· {{ msg.name }}</span>
              </div>
              <div>{{ displayContent(msg) }}</div>
              <!-- Show image attachments inside the bubble when present -->
              <div v-if="msg.images && msg.images.length" class="attachments">
                <div
                  class="thumb"
                  v-for="(img, i) in msg.images"
                  :key="img.id || i"><img :src="img.dataUrl" :alt="'attachment ' + (i + 1)" /></div>
              </div>
            </div>
          </template>
          <div v-if="assistantStreamingText" class="bubble assistant">
            <div class="role">assistant · streaming</div>
            <div>{{ displayStreamingText }}</div>
          </div>
        </div>

        <div class="input">
          <!-- Pasted image thumbnails (composer) -->
          <div
            class="attachments"
            v-if="inputImages.length"
            style="grid-column: 1 / -1"
          >
            <div class="thumb" v-for="img in inputImages" :key="img.id">
              <img :src="img.dataUrl" :alt="img.filename || 'image attachment'" />
              <button class="remove" @click="removeInputImage(img.id)" title="Remove">✕</button>
            </div>
          </div>
          <input
            v-model="userInput"
            :disabled="isStreaming"
            @keydown.enter="send"
            @paste="onPaste"
            placeholder="Describe a design or paste an image (Ctrl/Cmd+V)…"
          />
          <div style="display: flex; gap: 8px">
            <button class="btn" @click="stop" :disabled="!isStreaming">
              Stop
            </button>
            <button
              class="btn primary"
              @click="send"
              :disabled="!apiKey || (!userInput && !inputImages.length) || isStreaming"
            >
              Send
            </button>
          </div>
        </div>
      </section>

      <!-- RIGHT: Canvas -->
      <section class="right">
        <div class="canvas" ref="canvas">
          <div class="empty" v-if="!designs.length">
            <div>
              <div style="font-weight: 600; margin-bottom: 6px">
                No designs yet
              </div>
              <div class="hint">
                Describe a design in the chat to generate the first box.
              </div>
            </div>
          </div>

          <div
            v-for="d in designs"
            :key="d.id"
            class="box"
            :class="{preview: d.isPreview, fullscreen: d.isFullscreen}"
            :style="{left:d.x+'px', top:d.y+'px', width:d.width+'px', height:d.height+'px', zIndex:d.z}"
            :data-id="d.id"
            @mousedown="bringToFront(d.id)"
          >
            <div class="box-toolbar">
              <span class="title" @dblclick="renameDesign(d.id)"
                >{{ d.name || d.id }}</span
              >
              <span class="actions">
                <button title="Maximize" @click.stop="toggleFullscreen(d.id)">
                  ⧉
                </button>
                <button title="Export HTML" @click.stop="exportHtml(d.id)">
                  ⤓
                </button>
                <button title="Delete" @click.stop="removeDesign(d.id)">
                  ✕
                </button>
              </span>
            </div>
            <div class="box-content" :ref="'box-' + d.id"></div>
          </div>
        </div>
      </section>
    </div>

    <script>
      (function () {
        const TOOLS_SPEC = [
          {
            type: "function",
            function: {
              name: "create_design",
              description: "Create a new design box and render the given HTML.",
              parameters: {
                type: "object",
                properties: {
                  name: {
                    type: "string",
                    description: "Short label for the design."
                  },
                  html: {
                    type: "string",
                    description:
                      "Self-contained HTML fragment (no external deps). MUST be non-empty with actual HTML markup. Include inline <style> tags for styling. Avoid <script> unless explicitly requested.",
                    minLength: 1
                  },
                  width: { type: "number", default: 480 },
                  height: { type: "number", default: 360 },
                  x: { type: "number", default: 40 },
                  y: { type: "number", default: 40 },
                  renderMode: {
                    type: "string",
                    enum: ["shadow", "iframe"],
                    description:
                      "Optional override of render mode for this box."
                  }
                },
                required: ["name", "html"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "edit_design",
              description:
                "Modify an existing design by providing its ID/name and the new full HTML.",
              parameters: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "The ID of the design to edit."
                  },
                  name: {
                    type: "string",
                    description:
                      "The name of the design to edit (if ID is unknown)."
                  },
                  new_html: {
                    type: "string",
                    description:
                      "The new, complete HTML to replace the entire content of the design."
                  }
                },
                required: ["new_html"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "replace_string",
              description:
                "Surgical edit: replace a substring in the HTML of a specific design.",
              parameters: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "The ID of the design to edit."
                  },
                  name: {
                    type: "string",
                    description:
                      "The name of the design to edit (if ID is unknown)."
                  },
                  old: { type: "string" },
                  new: { type: "string" },
                  occurrences: {
                    type: "string",
                    enum: ["first", "all"],
                    default: "all"
                  }
                },
                required: ["old", "new"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "list_designs",
              description: "List current designs to find their ID and name.",
              parameters: { type: "object", properties: {} }
            }
          }
        ];

        const SYSTEM_PROMPT = `
You are a UI design assistant that creates HTML designs using the create_design tool.

When the user asks to create a design, call create_design with complete HTML:
{
  "html": "<div style='padding:40px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border-radius:12px; text-align:center'><h1 style='margin:0'>Hello World</h1><p style='margin-top:10px; opacity:0.9'>This is a sample design</p></div>",
  "name": "Sample Design"
}

The html parameter must contain complete, self-contained HTML with inline styles.

For editing existing designs:
- Use list_designs() to see all designs
- Use replace_string to change specific text
- Use edit_design to replace entire HTML

After creating or editing, confirm the action in a brief chat message.
`.trim();

        // Utilities
        const uid = () => Math.random().toString(36).slice(2, 10);
        const debounce = (fn, ms = 300) => {
          let t;
          return function (...a) {
            const context = this;
            clearTimeout(t);
            t = setTimeout(() => fn.apply(context, a), ms);
          };
        };
        const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Vue app
        new Vue({
          el: "#app",
          data: () => ({
            apiKey: localStorage.getItem("mini-stitch:apiKey") || "",
            model: localStorage.getItem("mini-stitch:model") || "gpt-4o-mini",
            renderModeDefault:
              localStorage.getItem("mini-stitch:renderModeDefault") || "shadow",
            isStreaming: false,
            userInput: "",
            inputImages: [], // queued images for next user message
            assistantStreamingText: "",
            messages: [],
            designs: [],
            _interactInit: {}, // id -> true
            _abortController: null,
            _streamLoopGuard: 0, // to prevent orphan loops
            // live preview state (via partial tool args only)
            previewBoxId: "__preview__",
            // keep the latest preview HTML so we can commit even if the tool args omit `html`
            previewLastHtml: "",
            // track last active design to resolve ambiguous edits
            lastActiveDesignId: null
          }),
          created() {
            // initial system prompt
            this.ensureSystemPrompt();
            // restore saved state
            this.restoreState();
          },
          mounted() {
            this.$watch(
              "designs",
              () => this.$nextTick(this.attachInteractions),
              { deep: true }
            );
          },
          methods: {
            displayContent(msg) {
              // For messages with content, display it
              if (msg.content && msg.content.trim()) {
                return msg.content;
              }
              // For tool-only messages (e.g., assistant with only tool_calls), show indicator
              if (msg.tool_calls && msg.tool_calls.length > 0) {
                const toolNames = msg.tool_calls
                  .map(tc => tc.function?.name || "unknown")
                  .join(", ");
                return `[Calling tools: ${toolNames}]`;
              }
              // Empty message
              return msg.content || "";
            },

            ensureSystemPrompt() {
              if (!this.messages.length || this.messages[0].role !== "system") {
                this.messages.unshift({
                  _id: uid(),
                  role: "system",
                  content: SYSTEM_PROMPT
                });
              }
            },
            saveState: debounce(function () {
              try {
                // IMPORTANT: Do NOT persist base64 images in chat history; they easily exceed localStorage.
                const messagesToSave = this.messages.map(m => {
                  const copy = Object.assign({}, m);
                  if (copy.images) {
                    // Drop images on persistence to keep storage small.
                    delete copy.images;
                  }
                  return copy;
                });
                localStorage.setItem(
                  "mini-stitch:messages",
                  JSON.stringify(messagesToSave)
                );
                localStorage.setItem(
                  "mini-stitch:designs",
                  JSON.stringify(
                    this.designs
                      .map(d => {
                        // Don't save renderer instances or preview boxes
                        const { _renderer, isPreview, ...rest } = d;
                        return isPreview ? null : rest;
                      })
                      .filter(Boolean)
                  )
                );
              } catch (e) {
                console.warn("Failed to save state:", e);
              }
            }, 500),
            restoreState() {
              try {
                const savedMessages = localStorage.getItem(
                  "mini-stitch:messages"
                );
                if (savedMessages) {
                  const parsed = JSON.parse(savedMessages);
                  if (Array.isArray(parsed) && parsed.length > 0) {
                    this.messages = parsed;
                  }
                }

                const savedDesigns = localStorage.getItem(
                  "mini-stitch:designs"
                );
                if (savedDesigns) {
                  const parsed = JSON.parse(savedDesigns);
                  if (Array.isArray(parsed) && parsed.length > 0) {
                    this.designs = parsed;
                    this.$nextTick(() => {
                      this.designs.forEach(d => this.renderDesign(d));
                    });
                  }
                }
              } catch (e) {
                console.warn("Failed to restore state:", e);
              }
            },
            persistApiKey() {
              localStorage.setItem("mini-stitch:apiKey", this.apiKey || "");
            },
            persistModel() {
              localStorage.setItem("mini-stitch:model", this.model || "");
            },
            persistRenderModeDefault() {
              localStorage.setItem(
                "mini-stitch:renderModeDefault",
                this.renderModeDefault || "shadow"
              );
            },

            // ===== Canvas helpers =====
            bringToFront(id) {
              const top = Math.max(0, ...this.designs.map(d => d.z || 0)) + 1;
              const d = this.getDesign(id);
              if (!d) return;
              Vue.set(d, "z", top);
              this.lastActiveDesignId = id;
            },
            renameDesign(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const name = prompt("New name for design:", d.name || "");
              if (name !== null) {
                d.name = name.trim();
              }
            },
            toggleFullscreen(id) {
              const d = this.getDesign(id);
              if (!d) return;
              Vue.set(d, "isFullscreen", !d.isFullscreen);
            },
            duplicateDesign(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const copy = JSON.parse(JSON.stringify(d));
              copy.id = uid();
              copy.name = (d.name || d.id) + " copy";
              copy.x += 20;
              copy.y += 20;
              copy.z = Math.max(...this.designs.map(x => x.z || 0)) + 1;
              copy.isPreview = false;
              this.designs.push(copy);
              this.$nextTick(() => this.renderDesign(copy));
              this.lastActiveDesignId = copy.id;
            },
            removeDesign(id) {
              const idx = this.designs.findIndex(d => d.id === id);
              if (idx >= 0) this.designs.splice(idx, 1);
            },
            getDesign(id) {
              return this.designs.find(d => d.id === id);
            },
            getDesignByName(name) {
              if (!name) return null;
              const n = String(name).trim().toLowerCase();
              return (
                this.designs.find(
                  d => (d.name || "").trim().toLowerCase() === n
                ) || null
              );
            },
            resolveDesignId(args) {
              // Priority: explicit id -> explicit name -> last active -> only design (if exactly 1)
              if (args && typeof args.id === "string" && args.id.trim())
                return args.id.trim();
              if (args && typeof args.name === "string") {
                const byName = this.getDesignByName(args.name);
                if (byName) return byName.id;
              }
              if (
                this.lastActiveDesignId &&
                this.getDesign(this.lastActiveDesignId)
              ) {
                return this.lastActiveDesignId;
              }
              if (this.designs.length === 1) return this.designs[0].id;
              return null;
            },
            listDesignsToChat() {
              const list = this.designs.map(d => ({
                id: d.id,
                name: d.name,
                size: { w: d.width, h: d.height },
                position: { x: d.x, y: d.y },
                updatedAt: d.updatedAt || d.createdAt
              }));
              this.messages.push({
                _id: uid(),
                role: "tool",
                name: "list_designs",
                content: JSON.stringify(list, null, 2)
              });
            },

            // ===== Rendering & isolation =====
            sanitize(html) {
              return DOMPurify.sanitize(html, {
                USE_PROFILES: { html: true },
                FORBID_TAGS: ["script", "iframe", "object", "embed", "link"]
                // DOMPurify by default strips event handlers (on*) and JS URLs.
              });
            },
            renderDesign(design) {
              const host = this.$refs["box-" + design.id];
              const el = Array.isArray(host) ? host[0] : host;
              if (!el) return;

              const sanitized = this.sanitize(design.html || "<div></div>");

              // Choose renderer
              const mode =
                design.renderMode || this.renderModeDefault || "shadow";
              if (mode === "iframe") {
                // sandboxed iframe (we control only from parent)
                el.innerHTML = "";
                const ifr = document.createElement("iframe");
                ifr.setAttribute("sandbox", "allow-scripts");
                ifr.style.border = "0";
                ifr.style.width = "100%";
                ifr.style.height = "100%";
                // Ensure dark-ish background inside
                const html = `
<!doctype html><html><head><meta charset="utf-8">
<style>html,body{height:100%;margin:0;background:#0b1220;color:#e5e7eb}</style>
</head><body>${sanitized}</body></html>`;
                ifr.srcdoc = html;
                el.appendChild(ifr);
                design._renderer = { mode: "iframe", node: ifr };
                return;
              }

              // Shadow DOM (open so we can update it)
              if (!el.shadowRoot) el.attachShadow({ mode: "open" });
              el.shadowRoot.innerHTML = sanitized;
              design._renderer = { mode: "shadow", node: el.shadowRoot };
            },
            ensurePreviewBox() {
              let d = this.getDesign(this.previewBoxId);
              if (!d) {
                const cx = 100,
                  cy = 80;
                d = {
                  id: this.previewBoxId,
                  name: "Preview",
                  isPreview: true,
                  html: '<div style="padding:16px;font:14px system-ui;color:#94a3b8">Generating preview…</div>',
                  x: cx,
                  y: cy,
                  width: 560,
                  height: 420,
                  z: Math.max(0, ...this.designs.map(x => x.z || 0)) + 1,
                  createdAt: Date.now(),
                  updatedAt: Date.now(),
                  renderMode: this.renderModeDefault
                };
                this.designs.push(d);
                this.$nextTick(() => this.renderDesign(d));
              }
              return d;
            },
            updatePreviewHtml(html) {
              const d = this.ensurePreviewBox();
              d.html = html;
              d.updatedAt = Date.now();
              // remember latest preview html for commit fallback
              this.previewLastHtml = html;
              this.$nextTick(() => this.renderDesign(d));
            },
            clearPreview() {
              const idx = this.designs.findIndex(
                d => d.id === this.previewBoxId
              );
              if (idx >= 0) this.designs.splice(idx, 1);
            },

            // ===== Interactions =====
            attachInteractions() {
              // Ensure _interactInit is initialized
              if (!this._interactInit) {
                this._interactInit = {};
              }

              // attach interact.js to each box once
              this.designs.forEach(d => {
                if (this._interactInit[d.id]) return;
                this._interactInit[d.id] = true;

                const selector = `.box[data-id="${d.id}"]`;
                interact(selector)
                  .draggable({
                    listeners: {
                      move: event => {
                        const id = event.target.dataset.id;
                        const dd = this.getDesign(id);
                        if (!dd) return;
                        dd.x += event.dx;
                        dd.y += event.dy;
                        event.target.style.left = dd.x + "px";
                        event.target.style.top = dd.y + "px";
                      }
                    },
                    inertia: false
                  })
                  .resizable({
                    edges: { left: true, right: true, bottom: true, top: true },
                    listeners: {
                      move: event => {
                        const id = event.target.dataset.id;
                        const dd = this.getDesign(id);
                        if (!dd) return;
                        dd.width = event.rect.width;
                        dd.height = event.rect.height;
                        dd.x += event.deltaRect.left;
                        dd.y += event.deltaRect.top;
                        const style = event.target.style;
                        style.width = dd.width + "px";
                        style.height = dd.height + "px";
                        style.left = dd.x + "px";
                        style.top = dd.y + "px";
                      }
                    }
                  });
              });
            },

            // ===== OpenAI chat orchestration =====

            // Handle clipboard images ------------------------------------------------
            async onPaste(e) {
              try {
                const items = Array.from(e.clipboardData?.items || []);
                const imageItems = items.filter(
                  it => it.kind === "file" && it.type && it.type.startsWith("image/")
                );
                if (!imageItems.length) return; // let normal text paste happen
                e.preventDefault();

                // API limit: up to 10 images per request (keep composer aligned)
                const remaining = Math.max(0, 10 - this.inputImages.length);
                for (const it of imageItems.slice(0, remaining)) {
                  const file = it.getAsFile();
                  if (file) await this.addInputImageFromFile(file);
                }
              } catch (err) {
                console.warn("Paste handling failed:", err);
              }
            },

            async addInputImageFromFile(file) {
              const processed = await this.downscaleImage(file, 1600);
              if (!processed) return;
              this.inputImages.push({
                id: uid(),
                filename: file.name || "",
                ...processed
              });
            },

            // Downscale & JPEG‑encode to keep payloads small
            downscaleImage(file, maxDim = 1600) {
              return new Promise(resolve => {
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                  let w = img.naturalWidth || img.width || 1;
                  let h = img.naturalHeight || img.height || 1;
                  const scale = Math.min(1, maxDim / Math.max(w, h));
                  const nw = Math.max(1, Math.round(w * scale));
                  const nh = Math.max(1, Math.round(h * scale));
                  const canvas = document.createElement("canvas");
                  canvas.width = nw;
                  canvas.height = nh;
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(img, 0, 0, nw, nh);
                  // Prefer JPEG for size; quality tuned for legibility
                  const dataUrl = canvas.toDataURL("image/jpeg", 0.85);
                  const sizeBytes = Math.ceil(
                    (dataUrl.length - (dataUrl.indexOf(",") + 1)) * 3 / 4
                  );
                  URL.revokeObjectURL(url);
                  resolve({
                    dataUrl,
                    mime: "image/jpeg",
                    width: nw,
                    height: nh,
                    sizeBytes
                  });
                };
                img.onerror = () => {
                  URL.revokeObjectURL(url);
                  resolve(null);
                };
                img.src = url;
              });
            },

            removeInputImage(id) {
              const idx = this.inputImages.findIndex(x => x.id === id);
              if (idx >= 0) this.inputImages.splice(idx, 1);
            },

            async send() {
              if (!this.apiKey) {
                alert("Provide an OpenAI API key first.");
                return;
              }
              if (!this.apiKey.startsWith("sk-")) {
                alert(
                  "Invalid API key format. OpenAI API keys should start with 'sk-'"
                );
                return;
              }
              const text = this.userInput.trim();
              const hasImages = this.inputImages && this.inputImages.length > 0;
              if (!text && !hasImages) return;

              this.ensureSystemPrompt();
              const userMsg = { _id: uid(), role: "user", content: text };
              if (hasImages) {
                userMsg.images = this.inputImages.map(img => ({
                  id: img.id,
                  dataUrl: img.dataUrl,
                  mime: img.mime,
                  width: img.width,
                  height: img.height,
                  sizeBytes: img.sizeBytes
                }));
              }
              this.messages.push(userMsg);
              this.userInput = "";
              this.inputImages = [];

              try {
                this.isStreaming = true;
                await this.chatLoop();
              } catch (e) {
                if (
                  e &&
                  (e.name === "AbortError" || String(e).includes("AbortError"))
                ) {
                  console.debug("Streaming aborted by user.");
                } else {
                  console.error("Request failed:", e);
                  let errorMsg = "Request failed. ";
                  if (e.message && e.message.includes("Failed to fetch")) {
                    errorMsg +=
                      "Network error - check your internet connection or CORS settings.";
                  } else if (e.message && e.message.includes("401")) {
                    errorMsg += "Invalid API key.";
                  } else if (e.message && e.message.includes("429")) {
                    errorMsg += "Rate limit exceeded.";
                  } else {
                    errorMsg += "See console for details.";
                  }
                  alert(errorMsg);
                }
              } finally {
                this.isStreaming = false;
                this.assistantStreamingText = "";
                this.clearPreview(); // remove any orphan preview when done
                this._abortController = null;
                this.$nextTick(() => {
                  const input = document.querySelector(".input input");
                  if (input) input.focus();
                });
              }
            },
            stop() {
              if (this._abortController) this._abortController.abort();
            },

            async chatLoop() {
              if (
                typeof this._streamLoopGuard !== "number" ||
                isNaN(this._streamLoopGuard)
              ) {
                this._streamLoopGuard = 0;
              }

              let continueLoop = true;
              let loopGuard = ++this._streamLoopGuard;
              let iteration = 0;
              let requireToolThisTurn = false; // Don't force tools - let model decide when ready
              const MAX_TOOL_ROUNDS = 6;

              while (continueLoop && loopGuard === this._streamLoopGuard) {
                iteration++;
                if (iteration > MAX_TOOL_ROUNDS) {
                  console.warn("Max tool rounds reached; aborting turn.");
                  break;
                }
                const result = await this.streamOnce({
                  toolChoice: requireToolThisTurn ? "required" : "auto"
                });

                if (result.toolCalls && result.toolCalls.length) {
                  let mutationSucceeded = false;
                  for (const call of result.toolCalls) {
                    const toolResult = await this.executeToolCall(
                      call.name,
                      call.args,
                      call.id
                    );
                    this.messages.push({
                      _id: uid(),
                      role: "tool",
                      name: call.name,
                      tool_call_id: call.id,
                      content: JSON.stringify(toolResult)
                    });
                    // Count ANY successful tool call as progress (not just mutations)
                    // This prevents infinite loops when model uses list_designs or other info tools
                    if (toolResult && !toolResult.error) {
                      mutationSucceeded = true;
                    }
                  }
                  // NEVER force tools - always let model decide
                  // This allows the model to respond with text after errors instead of being stuck in a tool-calling loop
                  requireToolThisTurn = false;
                  continueLoop = true;
                } else {
                  continueLoop = false;
                }
              }
            },

            async streamOnce(opts = {}) {
              this.assistantStreamingText = "";
              const toolBuffers = {}; // id -> { name, argsText }
              const indexToId = {}; // Map tool call index to its id
              const toolCalls = [];
              let assistantMessagePushed = false;
              let assistantMessage = {
                _id: uid(),
                role: "assistant",
                content: ""
              };

              const url = "https://api.openai.com/v1/chat/completions";
              const headers = {
                "Content-Type": "application/json",
                Authorization: "Bearer " + this.apiKey
              };

              const requestPayload = {
                model: this.model,
                stream: true,
                messages: this.messages.map(m => {
                  const { role, content, name, tool_call_id, tool_calls } = m;
                  const out = { role };

                  // If user message has images, build a multimodal content array
                  if (role === "user" && Array.isArray(m.images) && m.images.length > 0) {
                    const parts = [];
                    if (typeof content === "string" && content.trim()) {
                      parts.push({ type: "text", text: content });
                    }
                    for (const img of m.images) {
                      parts.push({
                        type: "image_url",
                        image_url: { url: img.dataUrl } // 'detail' defaults to 'auto'
                      });
                    }
                    out.content = parts;
                  } else if (content !== undefined) {
                    out.content = content;
                  }
                  if (name !== undefined) out.name = name;
                  if (tool_call_id !== undefined)
                    out.tool_call_id = tool_call_id;
                  if (tool_calls !== undefined) out.tool_calls = tool_calls;
                  return out;
                }),
                tools: TOOLS_SPEC,
                tool_choice: opts.toolChoice || "auto"
              };

              // DEBUG: Log the full request to see what we're sending to OpenAI
              console.log("[REQUEST] Sending to OpenAI:", {
                model: requestPayload.model,
                tool_choice: requestPayload.tool_choice,
                messageCount: requestPayload.messages.length,
                lastThreeMessages: requestPayload.messages.slice(-3).map(m => ({
                  role: m.role,
                  contentPreview: m.content
                    ? (typeof m.content === "string"
                        ? m.content.substring(0, 100)
                        : Array.isArray(m.content)
                          ? `[multimodal: ${m.content.length} parts]`
                          : "(complex content)")
                    : "(no content)",
                  hasToolCalls: !!m.tool_calls,
                  name: m.name
                }))
              });

              const body = JSON.stringify(requestPayload);
              const controller = new AbortController();
              this._abortController = controller;

              let res;
              try {
                res = await fetch(url, {
                  method: "POST",
                  headers,
                  body,
                  signal: controller.signal
                });
              } catch (fetchError) {
                console.error("Fetch failed:", fetchError);
                throw fetchError;
              }

              if (!res.ok || !res.body) {
                const err = await res.text().catch(() => String(res.status));
                console.error("OpenAI API error:", {
                  status: res.status,
                  statusText: res.statusText,
                  errorBody: err
                });
                throw new Error("OpenAI error: " + err);
              }

              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let buffer = "";

              const pushAssistantIfNeeded = () => {
                if (
                  !assistantMessagePushed &&
                  (assistantMessage.content.trim() ||
                    (assistantMessage.tool_calls &&
                      assistantMessage.tool_calls.length > 0))
                ) {
                  this.messages.push(assistantMessage);
                  assistantMessagePushed = true;
                }
              };

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                const lines = buffer.split("\n");
                buffer = lines.pop();

                for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed.startsWith("data:")) continue;
                  const data = trimmed.slice(5).trim();
                  if (data === "[DONE]") continue;

                  let evt;
                  try {
                    evt = JSON.parse(data);
                  } catch {
                    continue;
                  }
                  const choice = evt.choices && evt.choices[0];
                  if (!choice) continue;

                  const delta = choice.delta || {};
                  const finish = choice.finish_reason;

                  if (delta.content) {
                    assistantMessage.content += delta.content;
                    this.assistantStreamingText += delta.content;
                    this.scrollChatToEndSoon();
                  }

                  if (Array.isArray(delta.tool_calls)) {
                    for (const t of delta.tool_calls) {
                      console.log(
                        "[STREAM DELTA] tool_call chunk:",
                        JSON.stringify(t)
                      );

                      // Track index->id mapping when id first appears
                      if (t.id && t.index !== undefined) {
                        indexToId[t.index] = t.id;
                      }

                      // Use the tracked id for this index, or the id from this chunk
                      const toolId = indexToId[t.index] || t.id;

                      if (!toolId) {
                        console.warn(
                          "[STREAM DELTA] No id available for index",
                          t.index
                        );
                        continue;
                      }

                      if (!toolBuffers[toolId]) {
                        toolBuffers[toolId] = {
                          id: toolId,
                          name: t.function?.name || "",
                          argsText: ""
                        };
                      }

                      if (t.function?.name)
                        toolBuffers[toolId].name = t.function.name;
                      if (toolBuffers[toolId].name === "create_design") {
                        this.ensurePreviewBox();
                      }
                      if (t.function?.arguments) {
                        console.log(
                          "[STREAM DELTA] Appending arguments chunk:",
                          t.function.arguments
                        );
                        toolBuffers[toolId].argsText += t.function.arguments;
                        if (toolBuffers[toolId].name === "create_design") {
                          const partialHtml = this.extractPartialJsonString(
                            toolBuffers[toolId].argsText,
                            "html"
                          );
                          if (partialHtml) this.updatePreviewHtml(partialHtml);
                        }
                      }
                    }
                  }

                  if (finish === "tool_calls") {
                    const callsForMsg = Object.entries(toolBuffers)
                      .filter(
                        ([key, buf]) => buf.name && buf.name.trim() && buf.id
                      )
                      .map(([key, buf]) => ({
                        id: buf.id,
                        type: "function",
                        function: {
                          name: buf.name,
                          arguments: buf.argsText || "{}"
                        }
                      }));

                    if (callsForMsg.length > 0) {
                      assistantMessage.tool_calls = callsForMsg;
                    }

                    for (const [key, buf] of Object.entries(toolBuffers)) {
                      if (!buf.name || !buf.name.trim()) {
                        console.warn(
                          "Skipping tool call with empty name:",
                          key
                        );
                        continue;
                      }
                      if (!buf.id) {
                        console.warn("Skipping tool call without id:", key);
                        continue;
                      }

                      // DEBUG: Log what OpenAI actually sent
                      console.log(
                        `[STREAM] Tool: ${buf.name}, argsText length: ${buf.argsText.length}`
                      );
                      console.log(`[STREAM] argsText content: ${buf.argsText}`);

                      let args = {};
                      try {
                        args = JSON.parse(buf.argsText || "{}");
                        console.log("[STREAM] Parsed args:", args);
                      } catch (e) {
                        console.warn(
                          "Failed to parse tool args JSON, using fallback extraction:",
                          buf.argsText.substring(0, 100)
                        );
                        // Fallback: try to extract partial JSON fields
                        try {
                          const html = this.extractPartialJsonString(
                            buf.argsText,
                            "html"
                          );
                          if (html) args.html = html;
                          const name = this.extractPartialJsonString(
                            buf.argsText,
                            "name"
                          );
                          if (name) args.name = name;
                        } catch (extractError) {
                          console.warn(
                            "Partial extraction also failed, using empty args"
                          );
                        }
                      }
                      toolCalls.push({ id: buf.id, name: buf.name, args });
                    }
                  }
                }
              }
              pushAssistantIfNeeded();
              return { toolCalls };
            },

            // ===== Tool executors =====
            async executeToolCall(name, args, toolCallId) {
              try {
                if (name === "create_design")
                  return this.tool_create_design(args);
                if (name === "edit_design") return this.tool_edit_design(args);
                if (name === "replace_string")
                  return this.tool_replace_string(args);
                if (name === "list_designs") return this.tool_list_designs();
                return { error: "Unknown tool: " + name };
              } catch (e) {
                console.error("Tool error", name, e);
                return { error: String(e) };
              }
            },

            tool_create_design(args) {
              console.log("[CREATE_DESIGN] Called with args:", args);

              // STRICT VALIDATION: Return error if html is missing or empty
              // This forces the model to retry with proper HTML
              let html = typeof args.html === "string" ? args.html.trim() : "";
              console.log("[CREATE_DESIGN] HTML length:", html.length);

              if (!html) {
                console.error(
                  "[CREATE_DESIGN] ERROR: html parameter is required but was empty/missing"
                );
                return {
                  error: "missing_html",
                  message:
                    "CRITICAL: The 'html' parameter is REQUIRED and must contain actual HTML markup. You called create_design with empty or missing html. Example of correct call: create_design({html: \"<div style='padding:20px'>Hello World</div>\", name: \"MyDesign\"}). Please retry with proper HTML content."
                };
              }

              const id = uid();
              const d = {
                id,
                name: (args.name || "Untitled").toString().slice(0, 80),
                html: html,
                x: Number.isFinite(args.x) ? args.x : 40,
                y: Number.isFinite(args.y) ? args.y : 40,
                width: Number.isFinite(args.width) ? args.width : 560,
                height: Number.isFinite(args.height) ? args.height : 420,
                z: Math.max(0, ...this.designs.map(x => x.z || 0)) + 1,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                renderMode: args.renderMode || this.renderModeDefault
              };

              const previewIdx = this.designs.findIndex(
                x => x.id === this.previewBoxId
              );
              if (previewIdx >= 0) {
                const preview = this.designs[previewIdx];
                d.x = preview.x;
                d.y = preview.y;
                d.width = preview.width;
                d.height = preview.height;
                d.z = preview.z;
                this.designs.splice(previewIdx, 1, d);
                console.log(
                  "[CREATE_DESIGN] Replaced preview box with design, id:",
                  d.id
                );
              } else {
                this.designs.push(d);
                console.log(
                  "[CREATE_DESIGN] Added new design to array, id:",
                  d.id
                );
              }

              console.log(
                "[CREATE_DESIGN] Total designs now:",
                this.designs.length
              );
              console.log("[CREATE_DESIGN] Calling renderDesign...");
              this.$nextTick(() => this.renderDesign(d));
              this.previewLastHtml = "";
              this.lastActiveDesignId = d.id;
              console.log("[CREATE_DESIGN] Returning success:", {
                id: d.id,
                name: d.name
              });
              return { id: d.id, name: d.name };
            },

            tool_edit_design(args) {
              const resolvedId = this.resolveDesignId(args);
              if (!resolvedId) {
                return {
                  error: "design_not_found",
                  message:
                    "You must specify the 'id' or 'name' of the design to modify. Use list_designs() if you are unsure."
                };
              }
              const d = this.getDesign(resolvedId);
              if (!d)
                return {
                  error: "Design not found with resolved id: " + resolvedId
                };

              if (typeof args.new_html === "string" && args.new_html.trim()) {
                d.html = args.new_html;
                d.updatedAt = Date.now();
                this.$nextTick(() => this.renderDesign(d));
                this.lastActiveDesignId = d.id;
                return { id: d.id, status: "updated" };
              }

              return {
                error: "missing_parameters",
                message:
                  "edit_design requires the 'new_html' parameter with the full HTML content.",
                id: d.id
              };
            },

            tool_replace_string(args) {
              const resolvedId = this.resolveDesignId(args);
              if (!resolvedId) {
                return {
                  error: "design_not_found",
                  message:
                    "You must specify the 'id' or 'name' of the design to modify. Use list_designs() if you are unsure."
                };
              }
              const d = this.getDesign(resolvedId);
              if (!d)
                return {
                  error: "Design not found with resolved id: " + resolvedId
                };

              const oldS = String(args.old || "");
              const newS = String(args.new || "");
              if (!oldS)
                return {
                  error: "The 'old' string to be replaced cannot be empty."
                };

              let replacedCount = 0;
              if (args.occurrences === "first") {
                const idx = d.html.indexOf(oldS);
                if (idx !== -1) {
                  d.html =
                    d.html.slice(0, idx) +
                    newS +
                    d.html.slice(idx + oldS.length);
                  replacedCount = 1;
                }
              } else {
                const re = new RegExp(escapeRegExp(oldS), "g");
                replacedCount = (d.html.match(re) || []).length;
                d.html = d.html.replace(re, newS);
              }

              d.updatedAt = Date.now();
              this.$nextTick(() => this.renderDesign(d));
              this.lastActiveDesignId = d.id;
              return { id: d.id, replacedCount };
            },

            tool_list_designs() {
              const list = this.designs.map(d => ({
                id: d.id,
                name: d.name,
                size: { w: d.width, h: d.height },
                position: { x: d.x, y: d.y },
                z: d.z,
                updatedAt: d.updatedAt
              }));
              return list;
            },

            // ===== Preview helpers =====
            extractPartialJsonString(buf, field) {
              const key = `"${field}"`;
              const k = buf.indexOf(key);
              if (k === -1) return null;
              let i = buf.indexOf(":", k);
              if (i === -1) return null;
              while (i + 1 < buf.length && /\s/.test(buf[i + 1])) i++;
              if (buf[i + 1] !== '"') return null;
              let j = i + 2,
                out = "",
                esc = false;
              for (; j < buf.length; j++) {
                const ch = buf[j];
                if (esc) {
                  if (ch === "n") out += "\n";
                  else if (ch === "t") out += "\t";
                  else if (ch === "r") {
                    /* ignore */
                  } else out += ch;
                  esc = false;
                } else {
                  if (ch === "\\") esc = true;
                  else if (ch === '"') {
                    break;
                  } else out += ch;
                }
              }
              return out;
            },

            // ===== Misc =====
            scrollChatToEndSoon: debounce(function () {
              const el = this.$refs.chatScroll;
              if (el) el.scrollTop = el.scrollHeight;
            }, 40),
            clearChat() {
              if (!confirm("Clear chat history? (Designs will be kept)"))
                return;
              this.messages = [
                { _id: uid(), role: "system", content: SYSTEM_PROMPT }
              ];
            },
            newCanvas() {
              if (
                !confirm(
                  "Clear canvas and chat history (except system prompt)?"
                )
              )
                return;
              this.designs = [];
              this.messages = [
                { _id: uid(), role: "system", content: SYSTEM_PROMPT }
              ];
            },
            exportHtml(id) {
              const d = this.getDesign(id);
              if (!d) return;
              const sanitized = this.sanitize(d.html);
              const blob = new Blob([sanitized], { type: "text/html" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = (d.name || d.id).replace(/[^\w.-]+/g, "_") + ".html";
              document.body.appendChild(a);
              a.click();
              setTimeout(() => {
                URL.revokeObjectURL(url);
                a.remove();
              }, 100);
            }
          },
          computed: {
            displayStreamingText() {
              return this.assistantStreamingText || "";
            }
          },
          watch: {
            apiKey() {
              this.persistApiKey();
            },
            model() {
              this.persistModel();
            },
            renderModeDefault() {
              this.persistRenderModeDefault();
            },
            messages: {
              handler() {
                this.saveState();
              },
              deep: true
            },
            designs: {
              handler() {
                this.saveState();
              },
              deep: true
            }
          }
        });
      })();
    </script>

    <!-- SECURITY NOTE:
This is a client-only demo. Do NOT deploy with a long-lived API key.
For production, issue short-lived ephemeral tokens from a tiny server. -->
  </body>
</html>
